package Java8.LamdaFunction;


import java.util.List;

interface Square{
    int square(int a);
}
public class OwnLambda {
    public static void main(String[] args) {
        Square a  = x -> x*x;
        System.out.println(a.square(5));
        System.out.println(a.square(15));
        System.out.println(a.square(50));

        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        int sum = numbers.stream().reduce(0, Integer::sum);
        System.out.println(sum);

    }
}

/*
Q1->What happens behind the Scenes when you use Lambda Expression?
    // This is a pseudo code representation of what happens behind the scenes
Square a = new Square() {
    @Override
    public int square(int a) {
        return a * a;
    }
};

Summary:
Compiler's Role:

The compiler recognizes that the lambda expression is implementing a functional interface.
It compiles the lambda into bytecode with references to a synthetic class, but doesn't create the class itself.
JVM's Role:

At runtime, the JVM generates the synthetic class that implements the functional interface and provides the method body for the lambda expression.
The JVM creates an instance (object) of this synthetic class, which is the actual object that represents your lambda.
So, in essence:

The class is generated by the JVM at runtime, not by the compiler.
The object is also created by the JVM at runtime, and it's what you interact with when you use the lambda expression.

*/
